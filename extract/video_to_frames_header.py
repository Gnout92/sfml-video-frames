#!/usr/bin/env python3

"""
video_to_frames_header.py
-------------------------
Convert a video into a C/C++ header file (frames.h) containing a 2D array of
packed 1-bit frames for displays like 128x64. Each frame is WIDTH*HEIGHT/8 bytes,
with 8 horizontal pixels per byte (MSB-first).

Usage example:
  python video_to_frames_header.py -i input.mp4 -o frames.h --width 128 --height 64 --every 2 --threshold 127

If you want automatic threshold (Otsu):
  python video_to_frames_header.py -i input.mp4 -o frames.h --width 128 --height 64 --otsu

Invert black/white (useful if your renderer expects 1=white vs 1=black):
  python video_to_frames_header.py -i input.mp4 -o frames.h --invert

Dependencies:
  pip install opencv-python numpy
"""
import argparse
import os
import sys
from typing import Tuple, List

import cv2
import numpy as np


def pack_bits_row_major(binary_img: np.ndarray) -> np.ndarray:
    """
    Pack a 2D binary image (0 or 255) into bytes, row-major, 8 pixels per byte,
    MSB-first (leftmost pixel in a group of 8 is the highest bit).

    binary_img: shape (H, W), dtype uint8, values {0,255}
    returns: 1D array of length (W*H)//8, dtype uint8
    """
    h, w = binary_img.shape
    if w % 8 != 0:
        raise ValueError("Width must be divisible by 8 to pack bits cleanly. Got width=%d" % w)

    # Convert 255 -> 1, 0 -> 0
    bits = (binary_img > 0).astype(np.uint8)  # shape (H, W)

    # Reshape to groups of 8 horizontally
    bits = bits.reshape(h, w // 8, 8)  # (H, W/8, 8)

    # MSB-first: positions [7..0]
    weights = np.array([128, 64, 32, 16, 8, 4, 2, 1], dtype=np.uint16)  # shape (8,)
    packed = (bits * weights).sum(axis=2).astype(np.uint8)  # (H, W/8)

    return packed.flatten()  # length = (W*H)//8


def write_header(frames_bytes: List[np.ndarray], width: int, height: int, out_path: str, array_name: str = "allFrames"):
    """
    Write the frames to a C/C++ header file.
    frames_bytes: list of 1D uint8 arrays of length width*height/8
    """
    num_frames = len(frames_bytes)
    frame_size = (width * height) // 8

    with open(out_path, "w", encoding="utf-8") as f:
        f.write("// Auto-generated by video_to_frames_header.py\n")
        f.write("#pragma once\n")
        f.write("#include <cstdint>\n\n")
        f.write(f"constexpr int WIDTH = {width};\n")
        f.write(f"constexpr int HEIGHT = {height};\n")
        f.write(f"constexpr int FRAME_SIZE = (WIDTH * HEIGHT) / 8;\n")
        f.write(f"constexpr int NUM_FRAMES = {num_frames};\n\n")
        f.write(f"const uint8_t {array_name}[NUM_FRAMES][FRAME_SIZE] = {{\n")

        for i, fr in enumerate(frames_bytes):
            if fr.size != frame_size:
                raise ValueError(f"Frame {i} has size {fr.size}, expected {frame_size}")
            f.write("  {")
            for j, b in enumerate(fr):
                # print 16 bytes per line for readability
                if j > 0:
                    f.write(", ")
                f.write(f"0x{int(b):02x}")
                if (j + 1) % 16 == 0 and (j + 1) < fr.size:
                    f.write("\n   ")
            f.write("}")
            if i + 1 < num_frames:
                f.write(",")
            f.write("\n")
        f.write("};\n")

    print(f"[OK] Wrote {num_frames} frames to {out_path} "
          f"(each {frame_size} bytes, {width}x{height}, MSB-first 1-bit).")


def main():
    parser = argparse.ArgumentParser(description="Convert a video into a 1-bit packed C/C++ frames header (frames.h).")
    parser.add_argument("-i", "--input", required=True, help="Path to input video file")
    parser.add_argument("-o", "--output", default="frames.h", help="Output header path (default: frames.h)")
    parser.add_argument("--width", type=int, default=128, help="Target width (default: 128)")
    parser.add_argument("--height", type=int, default=64, help="Target height (default: 64)")
    parser.add_argument("--every", type=int, default=1, help="Keep every Nth frame (default: 1 = keep all)")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--threshold", type=int, default=None, help="Fixed threshold 0..255 (e.g. 127).")
    group.add_argument("--otsu", action="store_true", help="Use Otsu automatic thresholding.")
    parser.add_argument("--invert", action="store_true", help="Invert colors after threshold (swap black/white).")
    parser.add_argument("--max-frames", type=int, default=None, help="Limit maximum number of frames.")
    parser.add_argument("--array-name", type=str, default="allFrames", help="C array name (default: allFrames)")
    parser.add_argument("--interp", choices=["nearest", "area", "linear", "cubic"], default="area",
                        help="Resize interpolation (default: area).")

    args = parser.parse_args()

    if not os.path.exists(args.input):
        print(f"[ERR] Input video not found: {args.input}")
        sys.exit(1)

    # Pick OpenCV interpolation
    interp_map = {
        "nearest": cv2.INTER_NEAREST,
        "area": cv2.INTER_AREA,
        "linear": cv2.INTER_LINEAR,
        "cubic": cv2.INTER_CUBIC,
    }
    interp = interp_map[args.interp]

    cap = cv2.VideoCapture(args.input)
    if not cap.isOpened():
        print("[ERR] Could not open video.")
        sys.exit(2)

    frames_bytes = []
    idx = 0
    kept = 0

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        if idx % args.every != 0:
            idx += 1
            continue

        # 1) to grayscale
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        # 2) resize to target
        small = cv2.resize(gray, (args.width, args.height), interpolation=interp)
        # 3) threshold to binary
        if args.otsu:
            _, bw = cv2.threshold(small, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        else:
            thr = args.threshold if args.threshold is not None else 127
            _, bw = cv2.threshold(small, thr, 255, cv2.THRESH_BINARY)

        if args.invert:
            bw = cv2.bitwise_not(bw)

        # 4) pack to bytes (1-bit)
        packed = pack_bits_row_major(bw)  # 1D array length = width*height/8

        frames_bytes.append(packed)

        kept += 1
        idx += 1
        if args.max_frames is not None and kept >= args.max_frames:
            break

    cap.release()

    if not frames_bytes:
        print("[ERR] No frames were extracted. Check your --every/--max-frames settings or the video file.")
        sys.exit(3)

    write_header(frames_bytes, args.width, args.height, args.output, array_name=args.array_name)


if __name__ == "__main__":
    main()
