#!/usr/bin/env python3

"""
frames_dir_to_header.py
-----------------------
Build a C/C++ header (frames.h) from a directory of frame images
(e.g., PNG/JPG). Each image is converted to a 1-bit (black/white) 128x64 (or
custom size) frame, packed MSB-first with 8 horizontal pixels per byte.

Usage examples:
  python frames_dir_to_header.py --frames-dir D:\frames --width 128 --height 64 -o D:\frames.h --threshold 127
  python frames_dir_to_header.py --frames-dir ./frames --width 128 --height 64 -o frames.h --otsu --every 2
  python frames_dir_to_header.py --frames-dir ./frames -o frames.h --invert --glob "*.png"

Dependencies:
  pip install opencv-python numpy
"""
import argparse
import glob
import os
import re
import sys
from typing import List

import cv2
import numpy as np


def natural_key(s: str):
    """
    Sort helper for human-friendly ordering: frame_2.png < frame_10.png.
    Splits digits to integers.
    """
    return [int(text) if text.isdigit() else text.lower()
            for text in re.split(r'(\d+)', s)]


def pack_bits_row_major(binary_img: np.ndarray) -> np.ndarray:
    """
    Pack a 2D binary image (0 or 255) into bytes, row-major, 8 pixels per byte,
    MSB-first (leftmost pixel in a group of 8 is the highest bit).

    binary_img: shape (H, W), dtype uint8, values {0,255}
    returns: 1D array of length (W*H)//8, dtype uint8
    """
    h, w = binary_img.shape
    if w % 8 != 0:
        raise ValueError(f"Width must be divisible by 8 to pack bits cleanly. Got width={w}")

    bits = (binary_img > 0).astype(np.uint8)       # 255->1, 0->0
    bits = bits.reshape(h, w // 8, 8)              # groups of 8 horizontally
    weights = np.array([128,64,32,16,8,4,2,1], dtype=np.uint16)  # MSB-first
    packed = (bits * weights).sum(axis=2).astype(np.uint8)       # (H, W/8)
    return packed.flatten()                         # 1D length = (W*H)//8


def write_header(frames_bytes: List[np.ndarray], width: int, height: int,
                 out_path: str, array_name: str = "allFrames"):
    """
    Write frames into a C/C++ header file.
    """
    num_frames = len(frames_bytes)
    frame_size = (width * height) // 8

    with open(out_path, "w", encoding="utf-8") as f:
        f.write("// Auto-generated by frames_dir_to_header.py\n")
        f.write("#pragma once\n#include <cstdint>\n\n")
        f.write(f"constexpr int WIDTH = {width};\n")
        f.write(f"constexpr int HEIGHT = {height};\n")
        f.write(f"constexpr int FRAME_SIZE = (WIDTH * HEIGHT) / 8;\n")
        f.write(f"constexpr int NUM_FRAMES = {num_frames};\n\n")
        f.write(f"const uint8_t {array_name}[NUM_FRAMES][FRAME_SIZE] = {{\n")

        for i, fr in enumerate(frames_bytes):
            if fr.size != frame_size:
                raise ValueError(f"Frame {i} has size {fr.size}, expected {frame_size}")
            f.write("  {")
            for j, b in enumerate(fr):
                if j > 0:
                    f.write(", ")
                f.write(f"0x{int(b):02x}")
                if (j + 1) % 16 == 0 and (j + 1) < fr.size:
                    f.write("\n   ")
            f.write("}")
            if i + 1 < num_frames:
                f.write(",")
            f.write("\n")
        f.write("};\n")

    print(f"[OK] Wrote {num_frames} frames to {out_path} "
          f"(each {frame_size} bytes, {width}x{height}, 1-bit MSB-first).")


def main():
    parser = argparse.ArgumentParser(description="Convert a directory of frames into a 1-bit packed C/C++ header.")
    parser.add_argument("--frames-dir", required=True, help="Directory containing frame images (PNG/JPG/â€¦ )")
    parser.add_argument("-o", "--output", default="frames.h", help="Output header path (default: frames.h)")
    parser.add_argument("--width", type=int, default=128, help="Target width (default: 128)")
    parser.add_argument("--height", type=int, default=64, help="Target height (default: 64)")
    parser.add_argument("--glob", type=str, default="*.*", help="Glob pattern to match frames (default: *.*)")
    parser.add_argument("--every", type=int, default=1, help="Keep every Nth frame (default: 1 = keep all)")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("--threshold", type=int, default=None, help="Fixed threshold 0..255 (e.g. 127).")
    group.add_argument("--otsu", action="store_true", help="Use Otsu automatic thresholding.")

    parser.add_argument("--invert", action="store_true", help="Invert after thresholding (swap black/white).")
    parser.add_argument("--max-frames", type=int, default=None, help="Limit maximum number of frames.")
    parser.add_argument("--array-name", type=str, default="allFrames", help="C array name (default: allFrames)")

    parser.add_argument("--interp", choices=["nearest", "area", "linear", "cubic"], default="area",
                        help="Resize interpolation (default: area).")

    args = parser.parse_args()

    if not os.path.isdir(args.frames_dir):
        print(f"[ERR] Not a directory: {args.frames_dir}")
        sys.exit(1)

    # Collect files
    pattern = os.path.join(args.frames_dir, args.glob)
    files = glob.glob(pattern)
    if not files:
        print(f"[ERR] No files matched: {pattern}")
        sys.exit(2)

    files.sort(key=natural_key)

    interp_map = {
        "nearest": cv2.INTER_NEAREST,
        "area":    cv2.INTER_AREA,
        "linear":  cv2.INTER_LINEAR,
        "cubic":   cv2.INTER_CUBIC,
    }
    interp = interp_map[args.interp]

    frames_bytes = []
    kept = 0

    for idx, path in enumerate(files):
        if idx % args.every != 0:
            continue

        img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
        if img is None:
            print(f"[WARN] Failed to read image: {path}, skipping.")
            continue

        # Resize if needed
        if (img.shape[1] != args.width) or (img.shape[0] != args.height):
            img = cv2.resize(img, (args.width, args.height), interpolation=interp)

        # Threshold to binary
        if args.otsu:
            _, bw = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        else:
            thr = args.threshold if args.threshold is not None else 127
            _, bw = cv2.threshold(img, thr, 255, cv2.THRESH_BINARY)

        # Optional invert
        if args.invert:
            bw = cv2.bitwise_not(bw)

        # Pack to 1-bit
        packed = pack_bits_row_major(bw)
        frames_bytes.append(packed)
        kept += 1

        if args.max_frames is not None and kept >= args.max_frames:
            break

    if not frames_bytes:
        print("[ERR] No frames produced. Check inputs and options.")
        sys.exit(3)

    write_header(frames_bytes, args.width, args.height, args.output, array_name=args.array_name)


if __name__ == "__main__":
    main()
